# Database Migrations

This document explains how to work with database migrations in the OAuth SaaS Backend using Alembic.

## Overview

We use [Alembic](https://alembic.sqlalchemy.org/) for database schema migrations. Alembic is the database migration tool for SQLAlchemy and provides:

- **Version control** for database schemas
- **Automatic migration generation** based on model changes
- **Safe upgrades and downgrades** between schema versions
- **Production-ready** migration management

## Configuration

### Files Structure

```
backend/
├── alembic/                    # Alembic migration environment
│   ├── versions/               # Individual migration files
│   ├── env.py                  # Migration environment configuration
│   ├── script.py.mako          # Template for new migrations
│   └── README
├── alembic.ini                 # Alembic configuration file
├── migrate.py                  # Utility script for easy migration management
└── app/
    └── db/
        ├── database.py         # Database connection and Base
        └── models.py           # SQLAlchemy models
```

### Environment Setup

The migration environment is configured to:
- Use your application's `DATABASE_URL` from environment variables
- Import all models for autogenerate support
- Connect to PostgreSQL with proper settings

## Quick Start

### Using the Migration Utility Script

We provide a convenient `migrate.py` script for common operations:

```bash
# Check current migration status
python migrate.py current

# Check for pending migrations
python migrate.py check

# Create a new migration after model changes
python migrate.py create "add user profile fields"

# Apply all pending migrations
python migrate.py upgrade

# Apply migrations up to specific revision
python migrate.py upgrade +1

# Rollback to previous migration
python migrate.py downgrade -1

# View migration history
python migrate.py history

# Get help
python migrate.py help
```

### Using Alembic Directly

You can also use Alembic commands directly:

```bash
# Check current revision
alembic current

# Create new migration
alembic revision --autogenerate -m "migration description"

# Upgrade to latest
alembic upgrade head

# Downgrade one revision
alembic downgrade -1

# Show history
alembic history

# Show specific migration
alembic show 53ea32fb85b0
```

## Workflow

### 1. Making Model Changes

When you modify models in `app/db/models.py`:

```python
# Example: Adding a new field to User model
class User(Base):
    __tablename__ = "users"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String, unique=True, index=True, nullable=False)
    full_name = Column(String, index=True)
    is_active = Column(Boolean, default=True)
    # New field
    created_at = Column(DateTime(timezone=True), server_default=func.now())
```

### 2. Generate Migration

```bash
python migrate.py create "add created_at to users"
```

This creates a new file in `alembic/versions/` with the changes.

### 3. Review Migration

Always review the generated migration file before applying:

```python
def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True))
    # ### end Alembic commands ###
```

### 4. Apply Migration

```bash
python migrate.py upgrade
```

## Best Practices

### 1. Always Review Generated Migrations

- Check that the migration does what you expect
- Ensure data migrations are safe for production
- Add custom logic if needed

### 2. Test Migrations

- Test both upgrade and downgrade paths
- Test with realistic data volumes
- Verify indexes and constraints work as expected

### 3. Backup Before Production Migrations

```bash
# Example backup command (adjust for your setup)
pg_dump $DATABASE_URL > backup_$(date +%Y%m%d_%H%M%S).sql
```

### 4. Handle Data Migrations Carefully

For complex data transformations, consider:

```python
def upgrade() -> None:
    """Upgrade schema."""
    # Schema changes first
    op.add_column('users', sa.Column('full_name', sa.String(), nullable=True))
    
    # Data migration
    connection = op.get_bind()
    connection.execute(
        text("UPDATE users SET full_name = first_name || ' ' || last_name")
    )
    
    # Remove old columns
    op.drop_column('users', 'first_name')
    op.drop_column('users', 'last_name')
```

### 5. Use Meaningful Migration Messages

```bash
# Good
python migrate.py create "add user authentication fields"
python migrate.py create "create orders table with foreign keys"

# Not so good  
python migrate.py create "update db"
python migrate.py create "changes"
```

## Troubleshooting

### Migration Conflicts

If you get conflicts when multiple developers create migrations:

1. Pull latest changes
2. If needed, merge migration files manually
3. Update revision IDs to maintain proper chain

### Rolling Back Migrations

```bash
# Go back one migration
python migrate.py downgrade -1

# Go back to specific revision
python migrate.py downgrade abc123def456

# Go back to base (empty database)
python migrate.py downgrade base
```

### Checking Migration Status

```bash
# Current status
python migrate.py current

# Pending changes
python migrate.py check

# Full history
python migrate.py history
```

## Production Deployment

### 1. Backup Database

Always backup before applying migrations in production.

### 2. Apply Migrations

```bash
# In production environment
python migrate.py upgrade
```

### 3. Verify Application

Test that the application works correctly after migration.

## Common Commands Reference

| Command | Description |
|---------|-------------|
| `python migrate.py current` | Show current migration revision |
| `python migrate.py check` | Check for pending migrations |
| `python migrate.py create "message"` | Create new migration |
| `python migrate.py upgrade` | Apply all pending migrations |
| `python migrate.py upgrade +1` | Apply next migration only |
| `python migrate.py downgrade -1` | Rollback last migration |
| `python migrate.py history` | Show migration history |

## Advanced Usage

### Manual Migrations

For complex cases, you can create empty migrations and add custom logic:

```bash
alembic revision -m "custom data migration"
```

Then edit the generated file to add your custom logic.

### Multiple Database Support

If you need multiple databases, you can extend the configuration in `alembic.ini` and `env.py`.

## Migration Files

Migration files are stored in `alembic/versions/` and follow the naming pattern:
`{revision_id}_{description}.py`

Each file contains:
- **Revision metadata** (ID, parent, description, timestamp)  
- **upgrade()** function - applies the migration
- **downgrade()** function - reverses the migration

Never modify migration files after they've been applied in production!
